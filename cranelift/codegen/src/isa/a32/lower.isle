;; A32 instruction selection and CLIF-to-MachInst lowering.

;; The main lowering constructor term: takes a clif `Inst` and returns the
;; register(s) within which the lowered instruction's result values live.
(decl partial lower (Inst) InstOutput)


;;;; Rules for `null` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule 1 (lower (has_type (fits_in_32 ty) (null)))
  (load_imm32 ty 0))

(rule (lower (has_type $I64 (null)))
  (load_imm64 0))


;;;; Rules for `iconst` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule 1 (lower (has_type (fits_in_32 ty) (iconst (u64_from_imm64 n))))
  (load_imm32 ty n))

(rule (lower (has_type $I64 (iconst (u64_from_imm64 n))))
  (load_imm64 n))


;;;; Rules for `iadd` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule 3 (lower (has_type (fits_in_32 ty) (iadd x (imm15_from_value y))))
  (alu_reg_imm (AluOP.Add) x y))

(rule 2 (lower (has_type (fits_in_32 ty) (iadd (imm15_from_value x) y)))
  (alu_reg_imm (AluOP.Add) y x))

(rule 1 (lower (has_type (fits_in_32 ty) (iadd x y)))
  (alu_reg_reg (AluOP.Add) x y))

(rule
  (lower (has_type $I64 (iadd x y)))
  (let
    ( ;; low part
      (low Reg (alu_reg_reg (AluOP.Add) (value_regs_get x 0) (value_regs_get y 0)))
      ;; high part
      (high Reg (alu_reg_reg (AluOP.AddC) (value_regs_get x 1) (value_regs_get y 1))))
    (value_regs low high)))

(rule
  (lower (has_type $I128 (iadd x y)))
  (let
    ( (r1 Reg (alu_reg_reg (AluOP.Add) (value_regs_get x 0) (value_regs_get y 0)))
      (r2 Reg (alu_reg_reg (AluOP.AddC) (value_regs_get x 1) (value_regs_get y 1)))
      (r3 Reg (alu_reg_reg (AluOP.AddC) (value_regs_get x 2) (value_regs_get y 2)))
      (r4 Reg (alu_reg_reg (AluOP.AddC) (value_regs_get x 3) (value_regs_get y 3))))
    (value_regs_four r1 r2 r3 r4)))


;;;; Rules for `isub` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule 3 (lower (has_type (fits_in_32 ty) (isub x (imm15_from_value y))))
  (alu_reg_imm (AluOP.Sub) x y))

(rule 1 (lower (has_type (fits_in_32 ty) (isub x y)))
  (alu_reg_reg (AluOP.Sub) x y))

(rule
  (lower (has_type $I64 (isub x y)))
  (let
    ( ;; low part
      (low Reg (alu_reg_reg (AluOP.Sub) (value_regs_get x 0) (value_regs_get y 0)))
      ;; high part
      (high Reg (alu_reg_reg (AluOP.SubB) (value_regs_get x 1) (value_regs_get y 1))))
    (value_regs low high)))

(rule
  (lower (has_type $I128 (isub x y)))
  (let
    ( (r1 Reg (alu_reg_reg (AluOP.Sub) (value_regs_get x 0) (value_regs_get y 0)))
      (r2 Reg (alu_reg_reg (AluOP.SubB) (value_regs_get x 1) (value_regs_get y 1)))
      (r3 Reg (alu_reg_reg (AluOP.SubB) (value_regs_get x 2) (value_regs_get y 2)))
      (r4 Reg (alu_reg_reg (AluOP.SubB) (value_regs_get x 3) (value_regs_get y 3))))
    (value_regs_four r1 r2 r3 r4)))


;;;; Rules for `band` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule 3 (lower (has_type (fits_in_32 ty) (band x (imm15_from_value y))))
  (alu_reg_imm (AluOP.And) x y))

(rule 2 (lower (has_type (fits_in_32 ty) (band (imm15_from_value x) y)))
  (alu_reg_imm (AluOP.And) y x))

(rule 1 (lower (has_type (fits_in_32 ty) (band x y)))
  (alu_reg_reg (AluOP.And) x y))

(rule
  (lower (has_type $I64 (band x y)))
  (let
    ( ;; low part
      (low Reg (alu_reg_reg (AluOP.And) (value_regs_get x 0) (value_regs_get y 0)))
      ;; high part
      (high Reg (alu_reg_reg (AluOP.And) (value_regs_get x 1) (value_regs_get y 1))))
    (value_regs low high)))

(rule
  (lower (has_type $I128 (band x y)))
  (let
    ( (r1 Reg (alu_reg_reg (AluOP.And) (value_regs_get x 0) (value_regs_get y 0)))
      (r2 Reg (alu_reg_reg (AluOP.And) (value_regs_get x 1) (value_regs_get y 1)))
      (r3 Reg (alu_reg_reg (AluOP.And) (value_regs_get x 2) (value_regs_get y 2)))
      (r4 Reg (alu_reg_reg (AluOP.And) (value_regs_get x 3) (value_regs_get y 3))))
    (value_regs_four r1 r2 r3 r4)))


;;;; Rules for `bor` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule 3 (lower (has_type (fits_in_32 ty) (bor x (imm15_from_value y))))
  (alu_reg_imm (AluOP.Or) x y))

(rule 2 (lower (has_type (fits_in_32 ty) (bor (imm15_from_value x) y)))
  (alu_reg_imm (AluOP.Or) y x))

(rule 1 (lower (has_type (fits_in_32 ty) (bor x y)))
  (alu_reg_reg (AluOP.Or) x y))

(rule
  (lower (has_type $I64 (bor x y)))
  (let
    ( ;; low part
      (low Reg (alu_reg_reg (AluOP.Or) (value_regs_get x 0) (value_regs_get y 0)))
      ;; high part
      (high Reg (alu_reg_reg (AluOP.Or) (value_regs_get x 1) (value_regs_get y 1))))
    (value_regs low high)))

(rule
  (lower (has_type $I128 (bor x y)))
  (let
    ( (r1 Reg (alu_reg_reg (AluOP.Or) (value_regs_get x 0) (value_regs_get y 0)))
      (r2 Reg (alu_reg_reg (AluOP.Or) (value_regs_get x 1) (value_regs_get y 1)))
      (r3 Reg (alu_reg_reg (AluOP.Or) (value_regs_get x 2) (value_regs_get y 2)))
      (r4 Reg (alu_reg_reg (AluOP.Or) (value_regs_get x 3) (value_regs_get y 3))))
    (value_regs_four r1 r2 r3 r4)))


;;;; Rules for `bxor` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule 3 (lower (has_type (fits_in_32 ty) (bxor x (imm15_from_value y))))
  (alu_reg_imm (AluOP.Xor) x y))

(rule 2 (lower (has_type (fits_in_32 ty) (bxor (imm15_from_value x) y)))
  (alu_reg_imm (AluOP.Xor) y x))

(rule 1 (lower (has_type (fits_in_32 ty) (bxor x y)))
  (alu_reg_reg (AluOP.Xor) x y))

(rule
  (lower (has_type $I64 (bxor x y)))
  (let
    ( ;; low part
      (low Reg (alu_reg_reg (AluOP.Xor) (value_regs_get x 0) (value_regs_get y 0)))
      ;; high part
      (high Reg (alu_reg_reg (AluOP.Xor) (value_regs_get x 1) (value_regs_get y 1))))
    (value_regs low high)))

(rule
  (lower (has_type $I128 (bxor x y)))
  (let
    ( (r1 Reg (alu_reg_reg (AluOP.Xor) (value_regs_get x 0) (value_regs_get y 0)))
      (r2 Reg (alu_reg_reg (AluOP.Xor) (value_regs_get x 1) (value_regs_get y 1)))
      (r3 Reg (alu_reg_reg (AluOP.Xor) (value_regs_get x 2) (value_regs_get y 2)))
      (r4 Reg (alu_reg_reg (AluOP.Xor) (value_regs_get x 3) (value_regs_get y 3))))
    (value_regs_four r1 r2 r3 r4)))


;;;; Rules for `ishl` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule 3 (lower (has_type $I32 (ishl x (shamt32_from_value y))))
  (alu_reg_imm (AluOP.Shl) x y))

(rule 3 (lower (has_type $I16 (ishl x (shamt16_from_value y))))
  (alu_reg_imm (AluOP.Shl) x y))

(rule 3 (lower (has_type $I8 (ishl x (shamt8_from_value y))))
  (alu_reg_imm (AluOP.Shl) x y))

(rule 1 (lower (has_type (fits_in_32 ty) (ishl x y)))
  (alu_reg_reg (AluOP.Shl) x (mask_shamt ty (value_regs_get y 0))))

(rule (lower (has_type $I64 (ishl x y)))
  (lower_i64_ishl x y))

(rule (lower (has_type $I128 (ishl x y)))
  (libcall_2 (LibCall.Shl128) $I128 x $I8 (value_regs_get y 0) $I128))


;;;; Rules for `ushr` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule 3 (lower (has_type $I32 (ushr x (shamt32_from_value y))))
  (alu_reg_imm (AluOP.Lsr) x y))

(rule 3 (lower (has_type $I16 (ushr x (shamt16_from_value y))))
  (alu_reg_imm (AluOP.Lsr) x y))

(rule 3 (lower (has_type $I8 (ushr x (shamt8_from_value y))))
  (alu_reg_imm (AluOP.Lsr) x y))

(rule 1 (lower (has_type (fits_in_32 ty) (ushr x y)))
  (alu_reg_reg (AluOP.Lsr) x (mask_shamt ty (value_regs_get y 0))))

(rule (lower (has_type $I64 (ushr x y)))
  (lower_i64_ushr x y))

(rule (lower (has_type $I128 (ushr x y)))
  (libcall_2 (LibCall.UShr128) $I128 x $I8 (value_regs_get y 0) $I128))


;;;; Rules for `sshr` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule 3 (lower (has_type $I32 (sshr x (shamt32_from_value y))))
  (alu_reg_imm (AluOP.Asr) x y))

(rule 3 (lower (has_type $I16 (sshr x (shamt16_from_value y))))
  (alu_reg_imm (AluOP.Asr) x y))

(rule 3 (lower (has_type $I8 (sshr x (shamt8_from_value y))))
  (alu_reg_imm (AluOP.Asr) x y))

(rule 1 (lower (has_type (fits_in_32 ty) (sshr x y)))
  (alu_reg_reg (AluOP.Asr) x (mask_shamt ty (value_regs_get y 0))))

(rule (lower (has_type $I64 (sshr x y)))
  (lower_i64_sshr x y))

(rule (lower (has_type $I128 (sshr x y)))
  (libcall_2 (LibCall.SShr128) $I128 x $I8 (value_regs_get y 0) $I128))


;;;; Rules for `imul` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule 3 (lower (has_type (fits_in_32 ty) (imul x (imm15_from_value y))))
  (alu_reg_imm (AluOP.Mul) x y))

(rule 2 (lower (has_type (fits_in_32 ty) (imul (imm15_from_value x) y)))
  (alu_reg_imm (AluOP.Mul) y x))

(rule 1 (lower (has_type (fits_in_32 ty) (imul x y)))
  (alu_reg_reg (AluOP.Mul) x y))

(rule (lower (has_type $I64 (imul x y)))
  (lower_i64_imul x y))

(rule (lower (has_type $I128 (imul x y)))
  (libcall_2 (LibCall.Mul128) $I128 x $I128 y $I128))


;;;; Rules for `umulhi` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule 3 (lower (has_type $I32 (umulhi x (imm15_from_value y))))
  (alu_reg_imm (AluOP.MulHuu) x y))

(rule 2 (lower (has_type $I32 (umulhi (imm15_from_value x) y)))
  (alu_reg_imm (AluOP.MulHuu) y x))

(rule 1 (lower (has_type $I32 (umulhi x y)))
  (alu_reg_reg (AluOP.MulHuu) x y))

(rule (lower (has_type $I64 (umulhi x y)))
  (lower_i64_umulhi x y))


;;;; Rules for `smulhi` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule 3 (lower (has_type $I32 (smulhi x (imm15_from_value y))))
  (alu_reg_imm (AluOP.MulHss) x y))

(rule 2 (lower (has_type $I32 (smulhi (imm15_from_value x) y)))
  (alu_reg_imm (AluOP.MulHss) y x))

(rule 1 (lower (has_type $I32 (smulhi x y)))
  (alu_reg_reg (AluOP.MulHss) x y))

(rule (lower (has_type $I64 (smulhi x y)))
  (lower_i64_smulhi x y))


;;;; Rules for `udiv` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule 1 (lower (has_type (fits_in_32 ty) (udiv x y)))
  (libcall_2 (LibCall.UDiv32) $I32 x $I32 y $I32))

(rule (lower (has_type $I64 (udiv x y)))
  (libcall_2 (LibCall.UDiv64) $I64 x $I64 y $I64))

(rule (lower (has_type $I128 (udiv x y)))
  (libcall_2 (LibCall.UDiv128) $I128 x $I128 y $I128))


;;;; Rules for `sdiv` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule 1 (lower (has_type (fits_in_32 ty) (sdiv x y)))
  (libcall_2 (LibCall.SDiv32) $I32 x $I32 y $I32))

(rule (lower (has_type $I64 (sdiv x y)))
  (libcall_2 (LibCall.SDiv64) $I64 x $I64 y $I64))

(rule (lower (has_type $I128 (sdiv x y)))
  (libcall_2 (LibCall.SDiv128) $I128 x $I128 y $I128))


;;;; Rules for `urem` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule 1 (lower (has_type (fits_in_32 ty) (urem x y)))
  (libcall_2 (LibCall.URem32) $I32 x $I32 y $I32))

(rule (lower (has_type $I64 (urem x y)))
  (libcall_2 (LibCall.URem64) $I64 x $I64 y $I64))

(rule (lower (has_type $I128 (urem x y)))
  (libcall_2 (LibCall.URem128) $I128 x $I128 y $I128))


;;;; Rules for `srem` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule 1 (lower (has_type (fits_in_32 ty) (srem x y)))
  (libcall_2 (LibCall.SRem32) $I32 x $I32 y $I32))

(rule (lower (has_type $I64 (srem x y)))
  (libcall_2 (LibCall.SRem64) $I64 x $I64 y $I64))

(rule (lower (has_type $I128 (srem x y)))
  (libcall_2 (LibCall.SRem128) $I128 x $I128 y $I128))


;;;; Rules for `ineg` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule 1 (lower (has_type (fits_in_32 ty) (ineg x)))
  (alu_reg_neg x))

(rule
  (lower (has_type $I64 (ineg x)))
  (let
    ( ;; low part
      (low Reg (alu_reg_neg (value_regs_get x 0)))
      ;; high part
      (high Reg (alu_reg_negb (value_regs_get x 1))))
    (value_regs low high)))

(rule
  (lower (has_type $I128 (ineg x)))
  (let
    ( (r1 Reg (alu_reg_neg (value_regs_get x 0)))
      (r2 Reg (alu_reg_negb (value_regs_get x 1)))
      (r3 Reg (alu_reg_negb (value_regs_get x 2)))
      (r4 Reg (alu_reg_negb (value_regs_get x 3))))
    (value_regs_four r1 r2 r3 r4)))


;;;; Rules for `bnot` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule 1 (lower (has_type (fits_in_32 ty) (bnot x)))
  (alu_reg_not x))

(rule
  (lower (has_type $I64 (bnot x)))
  (let
    ( ;; low part
      (low Reg (alu_reg_not (value_regs_get x 0)))
      ;; high part
      (high Reg (alu_reg_not (value_regs_get x 1))))
    (value_regs low high)))

(rule
  (lower (has_type $I128 (bnot x)))
  (let
    ( (r1 Reg (alu_reg_not (value_regs_get x 0)))
      (r2 Reg (alu_reg_not (value_regs_get x 1)))
      (r3 Reg (alu_reg_not (value_regs_get x 2)))
      (r4 Reg (alu_reg_not (value_regs_get x 3))))
    (value_regs_four r1 r2 r3 r4)))



;;;; Rules for `band_not` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule 1 (lower (has_type (fits_in_32 ty) (band_not x y)))
  (lower_and_not x y))

(rule
  (lower (has_type $I64 (band_not x y)))
  (let
    ( ;; low part
      (low Reg (lower_and_not (value_regs_get x 0) (value_regs_get y 0)))
      ;; high part
      (high Reg (lower_and_not (value_regs_get x 1) (value_regs_get y 1))))
    (value_regs low high)))

(rule
  (lower (has_type $I128 (band_not x y)))
  (let
    ( (r1 Reg (lower_and_not (value_regs_get x 0) (value_regs_get y 0)))
      (r2 Reg (lower_and_not (value_regs_get x 1) (value_regs_get y 1)))
      (r3 Reg (lower_and_not (value_regs_get x 2) (value_regs_get y 2)))
      (r4 Reg (lower_and_not (value_regs_get x 3) (value_regs_get y 3))))
    (value_regs_four r1 r2 r3 r4)))


;;;; Rules for `bor_not` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule 1 (lower (has_type (fits_in_32 ty) (bor_not x y)))
  (lower_or_not x y))

(rule
  (lower (has_type $I64 (bor_not x y)))
  (let
    ( ;; low part
      (low Reg (lower_or_not (value_regs_get x 0) (value_regs_get y 0)))
      ;; high part
      (high Reg (lower_or_not (value_regs_get x 1) (value_regs_get y 1))))
    (value_regs low high)))

(rule
  (lower (has_type $I128 (bor_not x y)))
  (let
    ( (r1 Reg (lower_or_not (value_regs_get x 0) (value_regs_get y 0)))
      (r2 Reg (lower_or_not (value_regs_get x 1) (value_regs_get y 1)))
      (r3 Reg (lower_or_not (value_regs_get x 2) (value_regs_get y 2)))
      (r4 Reg (lower_or_not (value_regs_get x 3) (value_regs_get y 3))))
    (value_regs_four r1 r2 r3 r4)))


;;;; Rules for `bxor_not` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule 1 (lower (has_type (fits_in_32 ty) (bxor_not x y)))
  (lower_xor_not x y))

(rule
  (lower (has_type $I64 (bxor_not x y)))
  (let
    ( ;; low part
      (low Reg (lower_xor_not (value_regs_get x 0) (value_regs_get y 0)))
      ;; high part
      (high Reg (lower_xor_not (value_regs_get x 1) (value_regs_get y 1))))
    (value_regs low high)))

(rule
  (lower (has_type $I128 (bxor_not x y)))
  (let
    ( (r1 Reg (lower_xor_not (value_regs_get x 0) (value_regs_get y 0)))
      (r2 Reg (lower_xor_not (value_regs_get x 1) (value_regs_get y 1)))
      (r3 Reg (lower_xor_not (value_regs_get x 2) (value_regs_get y 2)))
      (r4 Reg (lower_xor_not (value_regs_get x 3) (value_regs_get y 3))))
    (value_regs_four r1 r2 r3 r4)))


;;; Rules for `iabs` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule 1
  (lower (has_type (fits_in_32 ty) (iabs x)))
  (let
    ( ;; negative
      (x_neg Reg (alu_reg_neg x))
      ;; extend to 32 bit for comparison
      (x_ext Reg (ext_to_32 $true x ty))
      (_ Unit (cmp_reg_imm x_ext (imm15 0))))
  (cond_move_reg_reg (IntCC.SignedLessThan) x x_neg)))

(rule
  (lower (has_type $I64 (iabs x)))
  (let
    ( ;; negative
      (low_neg Reg (alu_reg_neg (value_regs_get x 0)))
      (high_neg Reg (alu_reg_negb (value_regs_get x 1)))
      ;; compare upper word only
      (_ Unit (cmp_reg_imm (value_regs_get x 1) (imm15 0)))
      ;; select
      (low Reg (cond_move_reg_reg (IntCC.SignedLessThan) (value_regs_get x 0) low_neg))
      (high Reg (cond_move_reg_reg (IntCC.SignedLessThan) (value_regs_get x 1) high_neg)))
    (value_regs low high)))

(rule
  (lower (has_type $I128 (iabs x)))
  (let
    ( ;; negative
      (r1_neg Reg (alu_reg_neg (value_regs_get x 0)))
      (r2_neg Reg (alu_reg_negb (value_regs_get x 1)))
      (r3_neg Reg (alu_reg_negb (value_regs_get x 2)))
      (r4_neg Reg (alu_reg_negb (value_regs_get x 3)))
      ;; compare upper word only
      (_ Unit (cmp_reg_imm (value_regs_get x 3) (imm15 0)))
      ;; select
      (r1 Reg (cond_move_reg_reg (IntCC.SignedLessThan) (value_regs_get x 0) r1_neg))
      (r2 Reg (cond_move_reg_reg (IntCC.SignedLessThan) (value_regs_get x 1) r2_neg))
      (r3 Reg (cond_move_reg_reg (IntCC.SignedLessThan) (value_regs_get x 2) r3_neg))
      (r4 Reg (cond_move_reg_reg (IntCC.SignedLessThan) (value_regs_get x 3) r4_neg)))
    (value_regs_four r1 r2 r3 r4)))


;;;;;  Rules for `umin` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule 3
  (lower (has_type (fits_in_32 ty) (umin x (imm15_from_value y))))
  (let
    ( ;; extend to 32 bit for comparison
      (x_ext Reg (ext_to_32 $false x ty))
      (_ Unit (cmp_reg_imm x_ext y)))
  (cond_move_reg_imm (IntCC.UnsignedGreaterThan) x y)))

(rule 2
  (lower (has_type (fits_in_32 ty) (umin (imm15_from_value x) y)))
  (let
    ( ;; extend to 32 bit for comparison
      (y_ext Reg (ext_to_32 $false y ty))
      (_ Unit (cmp_reg_imm y_ext x)))
  (cond_move_reg_imm (IntCC.UnsignedGreaterThan) y x)))

(rule 1
  (lower (has_type (fits_in_32 ty) (umin x y)))
  (let
    ( ;; extend to 32 bit for comparison
      (x_ext Reg (ext_to_32 $false x ty))
      (y_ext Reg (ext_to_32 $false y ty))
      (_ Unit (cmp_reg_reg x_ext y_ext)))
  (cond_move_reg_reg (IntCC.UnsignedGreaterThan) x y)))

(rule
  (lower (has_type $I64 (umin x y)))
  (let
    ( ;; 64 bit compare
      (_ Unit (cmp_reg_reg (value_regs_get x 0) (value_regs_get y 0)))
      (_ Unit (cmpb_reg_reg (value_regs_get x 1) (value_regs_get y 1)))
      ;; 64 bit move
      (low Reg (cond_move_reg_reg (IntCC.UnsignedGreaterThan) (value_regs_get x 0) (value_regs_get y 0)))
      (high Reg (cond_move_reg_reg (IntCC.UnsignedGreaterThan) (value_regs_get x 1) (value_regs_get y 1))))
    (value_regs low high)))

(rule
  (lower (has_type $I128 (umin x y)))
  (let
    ( ;; 128 bit compare
      (_ Unit (cmp_reg_reg (value_regs_get x 0) (value_regs_get y 0)))
      (_ Unit (cmpb_reg_reg (value_regs_get x 1) (value_regs_get y 1)))
      (_ Unit (cmpb_reg_reg (value_regs_get x 2) (value_regs_get y 2)))
      (_ Unit (cmpb_reg_reg (value_regs_get x 3) (value_regs_get y 3)))
      ;; 128 bit move
      (r1 Reg (cond_move_reg_reg (IntCC.UnsignedGreaterThan) (value_regs_get x 0) (value_regs_get y 0)))
      (r2 Reg (cond_move_reg_reg (IntCC.UnsignedGreaterThan) (value_regs_get x 1) (value_regs_get y 1)))
      (r3 Reg (cond_move_reg_reg (IntCC.UnsignedGreaterThan) (value_regs_get x 2) (value_regs_get y 2)))
      (r4 Reg (cond_move_reg_reg (IntCC.UnsignedGreaterThan) (value_regs_get x 3) (value_regs_get y 3))))
    (value_regs_four r1 r2 r3 r4)))


;;;;;  Rules for `umax` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule 3
  (lower (has_type (fits_in_32 ty) (umax x (imm15_from_value y))))
  (let
    ( ;; extend to 32 bit for comparison
      (x_ext Reg (ext_to_32 $false x ty))
      (_ Unit (cmp_reg_imm x_ext y)))
  (cond_move_reg_imm (IntCC.UnsignedLessThan) x y)))

(rule 2
  (lower (has_type (fits_in_32 ty) (umax (imm15_from_value x) y)))
  (let
    ( ;; extend to 32 bit for comparison
      (y_ext Reg (ext_to_32 $false y ty))
      (_ Unit (cmp_reg_imm y_ext x)))
  (cond_move_reg_imm (IntCC.UnsignedLessThan) y x)))

(rule 1
  (lower (has_type (fits_in_32 ty) (umax x y)))
  (let
    ( ;; extend to 32 bit for comparison
      (x_ext Reg (ext_to_32 $false x ty))
      (y_ext Reg (ext_to_32 $false y ty))
      (_ Unit (cmp_reg_reg x_ext y_ext)))
  (cond_move_reg_reg (IntCC.UnsignedLessThan) x y)))

(rule
  (lower (has_type $I64 (umax x y)))
  (let
    ( ;; 64 bit compare
      (_ Unit (cmp_reg_reg (value_regs_get x 0) (value_regs_get y 0)))
      (_ Unit (cmpb_reg_reg (value_regs_get x 1) (value_regs_get y 1)))
      ;; 64 bit move
      (low Reg (cond_move_reg_reg (IntCC.UnsignedLessThan) (value_regs_get x 0) (value_regs_get y 0)))
      (high Reg (cond_move_reg_reg (IntCC.UnsignedLessThan) (value_regs_get x 1) (value_regs_get y 1))))
    (value_regs low high)))

(rule
  (lower (has_type $I128 (umax x y)))
  (let
    ( ;; 128 bit compare
      (_ Unit (cmp_reg_reg (value_regs_get x 0) (value_regs_get y 0)))
      (_ Unit (cmpb_reg_reg (value_regs_get x 1) (value_regs_get y 1)))
      (_ Unit (cmpb_reg_reg (value_regs_get x 2) (value_regs_get y 2)))
      (_ Unit (cmpb_reg_reg (value_regs_get x 3) (value_regs_get y 3)))
      ;; 128 bit move
      (r1 Reg (cond_move_reg_reg (IntCC.UnsignedLessThan) (value_regs_get x 0) (value_regs_get y 0)))
      (r2 Reg (cond_move_reg_reg (IntCC.UnsignedLessThan) (value_regs_get x 1) (value_regs_get y 1)))
      (r3 Reg (cond_move_reg_reg (IntCC.UnsignedLessThan) (value_regs_get x 2) (value_regs_get y 2)))
      (r4 Reg (cond_move_reg_reg (IntCC.UnsignedLessThan) (value_regs_get x 3) (value_regs_get y 3))))
    (value_regs_four r1 r2 r3 r4)))


;;;;;  Rules for `smin` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule 3
  (lower (has_type (fits_in_32 ty) (smin x (imm15_from_value y))))
  (let
    ( ;; extend to 32 bit for comparison
      (x_ext Reg (ext_to_32 $true x ty))
      (_ Unit (cmp_reg_imm x_ext y)))
  (cond_move_reg_imm (IntCC.SignedGreaterThan) x y)))

(rule 2
  (lower (has_type (fits_in_32 ty) (smin (imm15_from_value x) y)))
  (let
    ( ;; extend to 32 bit for comparison
      (y_ext Reg (ext_to_32 $true y ty))
      (_ Unit (cmp_reg_imm y_ext x)))
  (cond_move_reg_imm (IntCC.SignedGreaterThan) y x)))

(rule 1
  (lower (has_type (fits_in_32 ty) (smin x y)))
  (let
    ( ;; extend to 32 bit for comparison
      (x_ext Reg (ext_to_32 $true x ty))
      (y_ext Reg (ext_to_32 $true y ty))
      (_ Unit (cmp_reg_reg x_ext y_ext)))
  (cond_move_reg_reg (IntCC.SignedGreaterThan) x y)))

(rule
  (lower (has_type $I64 (smin x y)))
  (let
    ( ;; 64 bit compare
      (_ Unit (cmp_reg_reg (value_regs_get x 0) (value_regs_get y 0)))
      (_ Unit (cmpb_reg_reg (value_regs_get x 1) (value_regs_get y 1)))
      ;; 64 bit move
      (low Reg (cond_move_reg_reg (IntCC.SignedGreaterThan) (value_regs_get x 0) (value_regs_get y 0)))
      (high Reg (cond_move_reg_reg (IntCC.SignedGreaterThan) (value_regs_get x 1) (value_regs_get y 1))))
    (value_regs low high)))

(rule
  (lower (has_type $I128 (smin x y)))
  (let
    ( ;; 128 bit compare
      (_ Unit (cmp_reg_reg (value_regs_get x 0) (value_regs_get y 0)))
      (_ Unit (cmpb_reg_reg (value_regs_get x 1) (value_regs_get y 1)))
      (_ Unit (cmpb_reg_reg (value_regs_get x 2) (value_regs_get y 2)))
      (_ Unit (cmpb_reg_reg (value_regs_get x 3) (value_regs_get y 3)))
      ;; 128 bit move
      (r1 Reg (cond_move_reg_reg (IntCC.SignedGreaterThan) (value_regs_get x 0) (value_regs_get y 0)))
      (r2 Reg (cond_move_reg_reg (IntCC.SignedGreaterThan) (value_regs_get x 1) (value_regs_get y 1)))
      (r3 Reg (cond_move_reg_reg (IntCC.SignedGreaterThan) (value_regs_get x 2) (value_regs_get y 2)))
      (r4 Reg (cond_move_reg_reg (IntCC.SignedGreaterThan) (value_regs_get x 3) (value_regs_get y 3))))
    (value_regs_four r1 r2 r3 r4)))


;;;;;  Rules for `smax` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule 3
  (lower (has_type (fits_in_32 ty) (smax x (imm15_from_value y))))
  (let
    ( ;; extend to 32 bit for comparison
      (x_ext Reg (ext_to_32 $true x ty))
      (_ Unit (cmp_reg_imm x_ext y)))
  (cond_move_reg_imm (IntCC.SignedLessThan) x y)))

(rule 2
  (lower (has_type (fits_in_32 ty) (smax (imm15_from_value x) y)))
  (let
    ( ;; extend to 32 bit for comparison
      (y_ext Reg (ext_to_32 $true y ty))
      (_ Unit (cmp_reg_imm y_ext x)))
  (cond_move_reg_imm (IntCC.SignedLessThan) y x)))

(rule 1
  (lower (has_type (fits_in_32 ty) (smax x y)))
  (let
    ( ;; extend to 32 bit for comparison
      (x_ext Reg (ext_to_32 $true x ty))
      (y_ext Reg (ext_to_32 $true y ty))
      (_ Unit (cmp_reg_reg x_ext y_ext)))
  (cond_move_reg_reg (IntCC.SignedLessThan) x y)))

(rule
  (lower (has_type $I64 (smax x y)))
  (let
    ( ;; 64 bit compare
      (_ Unit (cmp_reg_reg (value_regs_get x 0) (value_regs_get y 0)))
      (_ Unit (cmpb_reg_reg (value_regs_get x 1) (value_regs_get y 1)))
      ;; 64 bit move
      (low Reg (cond_move_reg_reg (IntCC.SignedLessThan) (value_regs_get x 0) (value_regs_get y 0)))
      (high Reg (cond_move_reg_reg (IntCC.SignedLessThan) (value_regs_get x 1) (value_regs_get y 1))))
    (value_regs low high)))

(rule
  (lower (has_type $I128 (smax x y)))
  (let
    ( ;; 128 bit compare
      (_ Unit (cmp_reg_reg (value_regs_get x 0) (value_regs_get y 0)))
      (_ Unit (cmpb_reg_reg (value_regs_get x 1) (value_regs_get y 1)))
      (_ Unit (cmpb_reg_reg (value_regs_get x 2) (value_regs_get y 2)))
      (_ Unit (cmpb_reg_reg (value_regs_get x 3) (value_regs_get y 3)))
      ;; 128 bit move
      (r1 Reg (cond_move_reg_reg (IntCC.SignedLessThan) (value_regs_get x 0) (value_regs_get y 0)))
      (r2 Reg (cond_move_reg_reg (IntCC.SignedLessThan) (value_regs_get x 1) (value_regs_get y 1)))
      (r3 Reg (cond_move_reg_reg (IntCC.SignedLessThan) (value_regs_get x 2) (value_regs_get y 2)))
      (r4 Reg (cond_move_reg_reg (IntCC.SignedLessThan) (value_regs_get x 3) (value_regs_get y 3))))
    (value_regs_four r1 r2 r3 r4)))


;;;;;  Rules for `icmp` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule 3
  (lower (icmp cc x @ (value_type ty) (imm15_from_value y)))
  (let
    ( ;; extend to 32 bit for comparison
      (x_ext Reg (ext_to_32 (is_signed_cc cc) x ty))
      (_ Unit (cmp_reg_imm x_ext y)))
  (cond_move_reg_imm cc (zero_reg) (imm15 1))))

(rule 2
  (lower (icmp cc (imm15_from_value x) y @ (value_type ty)))
  (let
    ( ;; extend to 32 bit for comparison
      (y_ext Reg (ext_to_32 (is_signed_cc cc) y ty))
      (_ Unit (cmp_reg_imm y_ext x)))
  (cond_move_reg_imm (intcc_reverse cc) (zero_reg) (imm15 1))))

(rule 1
  (lower (icmp cc x @ (value_type ty) y))
  (let
    ( ;; extend to 32 bit for comparison
      (x_ext Reg (ext_to_32 (is_signed_cc cc) x ty))
      (y_ext Reg (ext_to_32 (is_signed_cc cc) y ty))
      (_ Unit (cmp_reg_reg x_ext y_ext)))
  (cond_move_reg_imm cc (zero_reg) (imm15 1))))

(rule 4
  (lower (icmp cc x @ (value_type $I64) y))
  (let
    ( ;; 64 bit compare
      (_ Unit (cmp_reg_reg (value_regs_get x 0) (value_regs_get y 0)))
      (_ Unit (cmpb_reg_reg (value_regs_get x 1) (value_regs_get y 1))))
    (cond_move_reg_imm cc (zero_reg) (imm15 1))))

(rule 4
  (lower (icmp cc x @ (value_type $I128) y))
  (let
    ( ;; 128 bit compare
      (_ Unit (cmp_reg_reg (value_regs_get x 0) (value_regs_get y 0)))
      (_ Unit (cmpb_reg_reg (value_regs_get x 1) (value_regs_get y 1)))
      (_ Unit (cmpb_reg_reg (value_regs_get x 2) (value_regs_get y 2)))
      (_ Unit (cmpb_reg_reg (value_regs_get x 3) (value_regs_get y 3))))
    (cond_move_reg_imm cc (zero_reg) (imm15 1))))


;;;;;  Rules for reference checks ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Null references are represented by the constant value `0`.
(rule (lower (is_null v @ (value_type $R32)))
  (let ((_ Unit (cmp_reg_imm v (imm15 0))))
    (cond_move_reg_imm (IntCC.Equal) (zero_reg) (imm15 1))))

;; Invalid references are represented by the constant value `-1`.
(rule (lower (is_invalid v @ (value_type $R32)))
  (let ((_ Unit (cmp_reg_imm v (imm15 -1))))
    (cond_move_reg_imm (IntCC.Equal) (zero_reg) (imm15 1))))


;;;; Rules for `get_return_address` and `get_{stack,frame}_pointer` ;;;;;;;;;;;;;

(rule (lower (get_return_address))
  (gen_move_from_preg (ra_reg)))

(rule (lower (get_stack_pointer))
  (gen_move_from_preg (sp_reg)))

(rule (lower (get_frame_pointer))
  (gen_move_from_preg (fp_reg)))


;;;; Rules for `extend` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule 1 (lower (has_type (fits_in_32 out_ty) (uextend x @ (value_type in_ty))))
  (lower_extend x $false (ty_bits in_ty) (ty_bits out_ty)))

(rule 1 (lower (has_type (fits_in_32 out_ty) (sextend x @ (value_type in_ty))))
  (lower_extend x $true (ty_bits in_ty) (ty_bits out_ty)))

(rule (lower (has_type $I64 (uextend x @ (value_type $I32))))
  (let
    ( ;; set high 32 bits
      (high Reg (load_imm (imm15 0))))
    (value_regs x high)))

(rule (lower (has_type $I64 (sextend x @ (value_type $I32))))
  (let
    ( ;; set high 32 bits
      (_ Unit (cmp_reg_imm x (imm15 0)))
      (high Reg (cond_move_reg_imm (IntCC.SignedLessThan) (zero_reg) (imm15 -1))))
    (value_regs x high)))

(rule (lower (has_type $I128 (uextend x @ (value_type $I32))))
  (let
    ( ;; set high 96 bits
      (r2 Reg (load_imm (imm15 0)))
      (r3 Reg (load_imm (imm15 0)))
      (r4 Reg (load_imm (imm15 0))))
    (value_regs_four x r2 r3 r4)))

(rule (lower (has_type $I128 (sextend x @ (value_type $I32))))
  (let
    ( ;; set high 96 bits
      (_ Unit (cmp_reg_imm x (imm15 0)))
      (r2 Reg (cond_move_reg_imm (IntCC.SignedLessThan) (zero_reg) (imm15 -1)))
      (r3 Reg (cond_move_reg_imm (IntCC.SignedLessThan) (zero_reg) (imm15 -1)))
      (r4 Reg (cond_move_reg_imm (IntCC.SignedLessThan) (zero_reg) (imm15 -1))))
    (value_regs_four x r2 r3 r4)))

(rule (lower (has_type $I128 (uextend x @ (value_type $I64))))
  (let
    ( ;; set high 64 bits
      (r3 Reg (load_imm (imm15 0)))
      (r4 Reg (load_imm (imm15 0))))
    (value_regs_four (value_regs_get x 0) (value_regs_get x 1) r3 r4)))

(rule (lower (has_type $I128 (sextend x @ (value_type $I64))))
  (let
    ( ;; set high 96 bits
      (_ Unit (cmp_reg_imm (value_regs_get x 1) (imm15 0)))
      (r3 Reg (cond_move_reg_imm (IntCC.SignedLessThan) (zero_reg) (imm15 -1)))
      (r4 Reg (cond_move_reg_imm (IntCC.SignedLessThan) (zero_reg) (imm15 -1))))
    (value_regs_four (value_regs_get x 0) (value_regs_get x 1) r3 r4)))

(rule -1 (lower (has_type $I64 (uextend x @ (value_type in_ty))))
  (let
    ( ;; extend low 32 bits
      (low Reg (lower_extend x $false (ty_bits in_ty) 32))
      ;; set high 32 bits
      (high Reg (load_imm (imm15 0))))
    (value_regs low high)))

(rule -1 (lower (has_type $I64 (sextend x @ (value_type in_ty))))
  (let
    ( ;; extend low 32 bits
      (low Reg (lower_extend x $true (ty_bits in_ty) 32))
      ;; set high 32 bits
      (_ Unit (cmp_reg_imm low (imm15 0)))
      (high Reg (cond_move_reg_imm (IntCC.SignedLessThan) (zero_reg) (imm15 -1))))
    (value_regs low high)))

(rule -1 (lower (has_type $I128 (uextend x @ (value_type in_ty))))
  (let
    ( ;; extend low 32 bits
      (r1 Reg (lower_extend x $false (ty_bits in_ty) 32))
      ;; set high 96 bits
      (r2 Reg (load_imm (imm15 0)))
      (r3 Reg (load_imm (imm15 0)))
      (r4 Reg (load_imm (imm15 0))))
    (value_regs_four r1 r2 r3 r4)))

(rule -1 (lower (has_type $I128 (sextend x @ (value_type in_ty))))
  (let
    ( ;; extend low 32 bits
      (r1 Reg (lower_extend x $true (ty_bits in_ty) 32))
      ;; set high 96 bits
      (_ Unit (cmp_reg_imm r1 (imm15 0)))
      (r2 Reg (cond_move_reg_imm (IntCC.SignedLessThan) (zero_reg) (imm15 -1)))
      (r3 Reg (cond_move_reg_imm (IntCC.SignedLessThan) (zero_reg) (imm15 -1)))
      (r4 Reg (cond_move_reg_imm (IntCC.SignedLessThan) (zero_reg) (imm15 -1))))
    (value_regs_four r1 r2 r3 r4)))


;;;;;  Rules for `load.i8` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule 1
  (lower (has_type $I8 (load _ (stack_addr ss offset1) offset2)))
  (gen_ss_load (LoadOP.Ld8) ss offset1 offset2))

(rule (lower (has_type $I8 (load _ base offset)))
  (load_reg_imm (LoadOP.Ld8) base offset))


;;;;;  Rules for `load.i16` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule 1
  (lower (has_type $I16 (uload8 _ (stack_addr ss offset1) offset2)))
  (gen_ss_load (LoadOP.Ld8) ss offset1 offset2))

(rule 1
  (lower (has_type $I16 (sload8 _ (stack_addr ss offset1) offset2)))
  (gen_ss_load (LoadOP.Ld8S) ss offset1 offset2))

(rule 1
  (lower (has_type $I16 (load _ (stack_addr ss offset1) offset2)))
  (gen_ss_load (LoadOP.Ld16) ss offset1 offset2))

(rule (lower (has_type $I16 (uload8 _ base offset)))
  (load_reg_imm (LoadOP.Ld8) base offset))

(rule (lower (has_type $I16 (sload8 _ base offset)))
  (load_reg_imm (LoadOP.Ld8S) base offset))

(rule (lower (has_type $I16 (load _ base offset)))
  (load_reg_imm (LoadOP.Ld16) base offset))


;;;;;  Rules for `load.i32` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule 1
  (lower (has_type $I32 (uload8 _ (stack_addr ss offset1) offset2)))
  (gen_ss_load (LoadOP.Ld8) ss offset1 offset2))

(rule 1
  (lower (has_type $I32 (sload8 _ (stack_addr ss offset1) offset2)))
  (gen_ss_load (LoadOP.Ld8S) ss offset1 offset2))

(rule 1
  (lower (has_type $I32 (uload16 _ (stack_addr ss offset1) offset2)))
  (gen_ss_load (LoadOP.Ld16) ss offset1 offset2))

(rule 1
  (lower (has_type $I32 (sload16 _ (stack_addr ss offset1) offset2)))
  (gen_ss_load (LoadOP.Ld16S) ss offset1 offset2))

(rule 1
  (lower (has_type $I32 (load _ (stack_addr ss offset1) offset2)))
  (gen_ss_load (LoadOP.Ld32) ss offset1 offset2))

(rule (lower (has_type $I32 (uload8 _ base offset)))
  (load_reg_imm (LoadOP.Ld8) base offset))

(rule (lower (has_type $I32 (sload8 _ base offset)))
  (load_reg_imm (LoadOP.Ld8S) base offset))

(rule (lower (has_type $I32 (uload16 _ base offset)))
  (load_reg_imm (LoadOP.Ld16) base offset))

(rule (lower (has_type $I32 (sload16 _ base offset)))
  (load_reg_imm (LoadOP.Ld16S) base offset))

(rule (lower (has_type $I32 (load _ base offset)))
  (load_reg_imm (LoadOP.Ld32) base offset))


;;;;;  Rules for `load.i64` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule 1
  (lower (has_type $I64 (uload8 _ (stack_addr ss offset1) offset2)))
  (let
    ( ;; low word
      (low Reg (gen_ss_load (LoadOP.Ld8) ss offset1 offset2))
      ;; high word
      (high Reg (load_imm (imm15 0))))
    (value_regs low high)))

(rule 1
  (lower (has_type $I64 (sload8 _ (stack_addr ss offset1) offset2)))
  (let
    ( ;; low word
      (low Reg (gen_ss_load (LoadOP.Ld8S) ss offset1 offset2))
      ;; high word
      (_ Unit (cmp_reg_imm low (imm15 0)))
      (high Reg (cond_move_reg_imm (IntCC.SignedLessThan) (zero_reg) (imm15 -1))))
    (value_regs low high)))

(rule 1
  (lower (has_type $I64 (uload16 _ (stack_addr ss offset1) offset2)))
  (let
    ( ;; low word
      (low Reg (gen_ss_load (LoadOP.Ld16) ss offset1 offset2))
      ;; high word
      (high Reg (load_imm (imm15 0))))
    (value_regs low high)))

(rule 1
  (lower (has_type $I64 (sload16 _ (stack_addr ss offset1) offset2)))
  (let
    ( ;; low word
      (low Reg (gen_ss_load (LoadOP.Ld16S) ss offset1 offset2))
      ;; high word
      (_ Unit (cmp_reg_imm low (imm15 0)))
      (high Reg (cond_move_reg_imm (IntCC.SignedLessThan) (zero_reg) (imm15 -1))))
    (value_regs low high)))

(rule 1
  (lower (has_type $I64 (uload32 _ (stack_addr ss offset1) offset2)))
  (let
    ( ;; low word
      (low Reg (gen_ss_load (LoadOP.Ld32) ss offset1 offset2))
      ;; high word
      (high Reg (load_imm (imm15 0))))
    (value_regs low high)))

(rule 1
  (lower (has_type $I64 (sload32 _ (stack_addr ss offset1) offset2)))
  (let
    ( ;; low word
      (low Reg (gen_ss_load (LoadOP.Ld32) ss offset1 offset2))
      ;; high word
      (_ Unit (cmp_reg_imm low (imm15 0)))
      (high Reg (cond_move_reg_imm (IntCC.SignedLessThan) (zero_reg) (imm15 -1))))
    (value_regs low high)))

(rule 1
  (lower (has_type $I64 (load _ (stack_addr ss offset1) offset2)))
  (let
    ( ;; low word
      (low Reg (gen_ss_load (LoadOP.Ld32) ss offset1 offset2))
      ;; high word
      (high Reg (gen_ss_load (LoadOP.Ld32) ss offset1 (add_offset offset2 4))))
    (value_regs low high)))

(rule
  (lower (has_type $I64 (uload8 _ base offset)))
  (let
    ( ;; low word
      (low Reg (load_reg_imm (LoadOP.Ld8) base offset))
      ;; high word
      (high Reg (load_imm (imm15 0))))
    (value_regs low high)))

(rule
  (lower (has_type $I64 (sload8 _ base offset)))
  (let
    ( ;; low word
      (low Reg (load_reg_imm (LoadOP.Ld8S) base offset))
      ;; high word
      (_ Unit (cmp_reg_imm low (imm15 0)))
      (high Reg (cond_move_reg_imm (IntCC.SignedLessThan) (zero_reg) (imm15 -1))))
    (value_regs low high)))

(rule
  (lower (has_type $I64 (uload16 _ base offset)))
  (let
    ( ;; low word
      (low Reg (load_reg_imm (LoadOP.Ld16) base offset))
      ;; high word
      (high Reg (load_imm (imm15 0))))
    (value_regs low high)))

(rule
  (lower (has_type $I64 (sload16 _ base offset)))
  (let
    ( ;; low word
      (low Reg (load_reg_imm (LoadOP.Ld16S) base offset))
      ;; high word
      (_ Unit (cmp_reg_imm low (imm15 0)))
      (high Reg (cond_move_reg_imm (IntCC.SignedLessThan) (zero_reg) (imm15 -1))))
    (value_regs low high)))

(rule
  (lower (has_type $I64 (uload32 _ base offset)))
  (let
    ( ;; low word
      (low Reg (load_reg_imm (LoadOP.Ld32) base offset))
      ;; high word
      (high Reg (load_imm (imm15 0))))
    (value_regs low high)))

(rule
  (lower (has_type $I64 (sload32 _ base offset)))
  (let
    ( ;; low word
      (low Reg (load_reg_imm (LoadOP.Ld32) base offset))
      ;; high word
      (_ Unit (cmp_reg_imm low (imm15 0)))
      (high Reg (cond_move_reg_imm (IntCC.SignedLessThan) (zero_reg) (imm15 -1))))
    (value_regs low high)))

(rule
  (lower (has_type $I64 (load _ base offset)))
  (let
    ( ;; low word
      (low Reg (load_reg_imm (LoadOP.Ld32) base offset))
      ;; high word
      (high Reg (load_reg_imm (LoadOP.Ld32) base (add_offset offset 4))))
    (value_regs low high)))


;;;;;  Rules for `load.i128` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule 1
  (lower (has_type $I128 (load _ (stack_addr ss offset1) offset2)))
  (let
    ( (r1 Reg (gen_ss_load (LoadOP.Ld32) ss offset1 offset2))
      (r2 Reg (gen_ss_load (LoadOP.Ld32) ss offset1 (add_offset offset2 4)))
      (r3 Reg (gen_ss_load (LoadOP.Ld32) ss offset1 (add_offset offset2 8)))
      (r4 Reg (gen_ss_load (LoadOP.Ld32) ss offset1 (add_offset offset2 12))))
    (value_regs_four r1 r2 r3 r4)))

(rule
  (lower (has_type $I128 (load _ base offset)))
  (let
    ( (r1 Reg (load_reg_imm (LoadOP.Ld32) base offset))
      (r2 Reg (load_reg_imm (LoadOP.Ld32) base (add_offset offset 4)))
      (r3 Reg (load_reg_imm (LoadOP.Ld32) base (add_offset offset 8)))
      (r4 Reg (load_reg_imm (LoadOP.Ld32) base (add_offset offset 12))))
    (value_regs_four r1 r2 r3 r4)))


;;;;  Rules for `store.i8` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule 1
  (lower (store _ x @ (value_type $I8) (stack_addr ss offset1) offset2))
  (gen_ss_store (StoreOP.St8) ss offset1 offset2 x))

(rule (lower (store _ x @ (value_type $I8) base offset))
  (store_reg_imm (StoreOP.St8) x base offset))


;;;;  Rules for `store.i16` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule 1
  (lower (istore8 _ x @ (value_type $I16) (stack_addr ss offset1) offset2))
  (gen_ss_store (StoreOP.St8) ss offset1 offset2 x))

(rule 1
  (lower (store _ x @ (value_type $I16) (stack_addr ss offset1) offset2))
  (gen_ss_store (StoreOP.St16) ss offset1 offset2 x))

(rule (lower (istore8 _ x @ (value_type $I16) base offset))
  (store_reg_imm (StoreOP.St8) x base offset))

(rule (lower (store _ x @ (value_type $I16) base offset))
  (store_reg_imm (StoreOP.St16) x base offset))


;;;;  Rules for `store.i32` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule 1
  (lower (istore8 _ x @ (value_type $I32) (stack_addr ss offset1) offset2))
  (gen_ss_store (StoreOP.St8) ss offset1 offset2 x))

(rule 1
  (lower (istore16 _ x @ (value_type $I32) (stack_addr ss offset1) offset2))
  (gen_ss_store (StoreOP.St16) ss offset1 offset2 x))

(rule 1
  (lower (store _ x @ (value_type $I32) (stack_addr ss offset1) offset2))
  (gen_ss_store (StoreOP.St32) ss offset1 offset2 x))

(rule (lower (istore8 _ x @ (value_type $I32) base offset))
  (store_reg_imm (StoreOP.St8) x base offset))

(rule (lower (istore16 _ x @ (value_type $I32) base offset))
  (store_reg_imm (StoreOP.St16) x base offset))

(rule (lower (store _ x @ (value_type $I32) base offset))
  (store_reg_imm (StoreOP.St32) x base offset))


;;;;  Rules for `store.i64` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule 1
  (lower (istore8 _ x @ (value_type $I64) (stack_addr ss offset1) offset2))
  (gen_ss_store (StoreOP.St8) ss offset1 offset2 (value_regs_get x 0)))

(rule 1
  (lower (istore16 _ x @ (value_type $I64) (stack_addr ss offset1) offset2))
  (gen_ss_store (StoreOP.St16) ss offset1 offset2 (value_regs_get x 0)))

(rule 1
  (lower (istore32 _ x @ (value_type $I64) (stack_addr ss offset1) offset2))
  (gen_ss_store (StoreOP.St32) ss offset1 offset2 (value_regs_get x 0)))

(rule 1
  (lower (store _ x @ (value_type $I64) (stack_addr ss offset1) offset2))
  (let
    ((_ InstOutput (gen_ss_store (StoreOP.St32) ss offset1 offset2 (value_regs_get x 0))))
    (gen_ss_store (StoreOP.St32) ss offset1 (add_offset offset2 4) (value_regs_get x 1))))

(rule (lower (istore8 _ x @ (value_type $I64) base offset))
  (store_reg_imm (StoreOP.St8) (value_regs_get x 0) base offset))

(rule (lower (istore16 _ x @ (value_type $I64) base offset))
  (store_reg_imm (StoreOP.St16) (value_regs_get x 0) base offset))

(rule (lower (istore32 _ x @ (value_type $I64) base offset))
  (store_reg_imm (StoreOP.St32) (value_regs_get x 0) base offset))

(rule (lower (store _ x @ (value_type $I64) base offset))
  (side_effect (SideEffectNoResult.Inst2
    ;; low word
    (MInst.Store (StoreOP.St32) (value_regs_get x 0) (build_amode base offset))
    ;; high word
    (MInst.Store (StoreOP.St32) (value_regs_get x 1) (build_amode base (add_offset offset 4))))))


;;;;  Rules for `store.i128` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule 1
  (lower (store _ x @ (value_type $I128) (stack_addr ss offset1) offset2))
  (let
    ( (_ InstOutput (gen_ss_store (StoreOP.St32) ss offset1 offset2 (value_regs_get x 0)))
      (_ InstOutput (gen_ss_store (StoreOP.St32) ss offset1 (add_offset offset2 4) (value_regs_get x 1)))
      (_ InstOutput (gen_ss_store (StoreOP.St32) ss offset1 (add_offset offset2 8) (value_regs_get x 2))))
    (gen_ss_store (StoreOP.St32) ss offset1 (add_offset offset2 12) (value_regs_get x 3))))

(rule (lower (store _ x @ (value_type $I128) base offset))
  (side_effect (SideEffectNoResult.Inst4
    (MInst.Store (StoreOP.St32) (value_regs_get x 0) (build_amode base offset))
    (MInst.Store (StoreOP.St32) (value_regs_get x 1) (build_amode base (add_offset offset 4)))
    (MInst.Store (StoreOP.St32) (value_regs_get x 2) (build_amode base (add_offset offset 8)))
    (MInst.Store (StoreOP.St32) (value_regs_get x 3) (build_amode base (add_offset offset 12))))))


;;;; Rules for calls ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule (lower (call (func_ref_data sig_ref extname dist) inputs))
  (gen_call sig_ref extname dist inputs))

(rule (lower (call_indirect sig_ref val inputs))
  (gen_call_indirect sig_ref val inputs))

;; N.B.: the Ret itself is generated by the ABI.
(rule (lower (return args))
  (lower_return (range 0 (value_slice_len args)) args))


;;;;; Rules for `symbol_value` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule
   (lower (symbol_value (symbol_value_data name _ offset)))
   (load_ext_name name offset))

(rule
  (lower (func_addr (func_ref_data _ name _)))
  (load_ext_name name 0))


;; Variant of the main lowering constructor term, which receives an
;; additional argument (a vector of branch targets to be used) for
;; implementing branches.
;; For two-branch instructions, the first target is `taken` and the second
;; `not_taken`, even if it is a Fallthrough instruction: because we reorder
;; blocks while we lower, the fallthrough in the new order is not (necessarily)
;; the same as the fallthrough in CLIF. So, we use the explicitly-provided
;; target.
(decl partial lower_branch (Inst VecMachLabel) Unit)


;;;; Rules for `brif` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; `brif` following `icmp`
(rule -1
  (lower_branch (brif (icmp cc x @ (value_type $I64) y) _ _) targets)
  (let
    ( ;; targets
      (taken JumpTarget (jump_target targets 0))
      (not_taken JumpTarget (jump_target targets 1))
      ;; comparison
      (_ Unit (cmp_reg_reg (value_regs_get x 0) (value_regs_get y 0)))
      (_ Unit (cmpb_reg_reg (value_regs_get x 1) (value_regs_get y 1))))
    (branch_rel cc taken not_taken)))

(rule -1
  (lower_branch (brif (icmp cc x @ (value_type $I128) y) _ _) targets)
  (let
    ( ;; targets
      (taken JumpTarget (jump_target targets 0))
      (not_taken JumpTarget (jump_target targets 1))
      ;; comparison
      (_ Unit (cmp_reg_reg (value_regs_get x 0) (value_regs_get y 0)))
      (_ Unit (cmpb_reg_reg (value_regs_get x 1) (value_regs_get y 1)))
      (_ Unit (cmpb_reg_reg (value_regs_get x 2) (value_regs_get y 2)))
      (_ Unit (cmpb_reg_reg (value_regs_get x 3) (value_regs_get y 3))))
    (branch_rel cc taken not_taken)))

(rule -2
  (lower_branch (brif (maybe_uextend (icmp cc x @ (value_type ty) y)) _ _) targets)
  (let
    ( ;; targets
      (taken JumpTarget (jump_target targets 0))
      (not_taken JumpTarget (jump_target targets 1))
      ;; extend to 32 bit for comparison
      (x_ext Reg (ext_to_32 (is_signed_cc cc) x ty))
      (y_ext Reg (ext_to_32 (is_signed_cc cc) y ty))
      ;; comparison
      (_ Unit (cmp_reg_reg x_ext y_ext)))
    (branch_rel cc taken not_taken)))

;; standard `brif`
(rule -3
  (lower_branch (brif c @ (value_type $I64) _ _) targets)
  (let
    ( ;; targets
      (taken JumpTarget (jump_target targets 0))
      (not_taken JumpTarget (jump_target targets 1))
      ;; comparison
      (_ Unit (cmp_reg_imm (value_regs_get c 0) (imm15 0)))
      (_ Unit (cmpb_reg_imm (value_regs_get c 1) (imm15 0))))
    (branch_rel (IntCC.NotEqual) taken not_taken)))

(rule -3
  (lower_branch (brif c @ (value_type $I128) _ _) targets)
  (let
    ( ;; targets
      (taken JumpTarget (jump_target targets 0))
      (not_taken JumpTarget (jump_target targets 1))
      ;; comparison
      (_ Unit (cmp_reg_imm (value_regs_get c 0) (imm15 0)))
      (_ Unit (cmpb_reg_imm (value_regs_get c 1) (imm15 0)))
      (_ Unit (cmpb_reg_imm (value_regs_get c 2) (imm15 0)))
      (_ Unit (cmpb_reg_imm (value_regs_get c 3) (imm15 0))))
    (branch_rel (IntCC.NotEqual) taken not_taken)))

(rule -4
  (lower_branch (brif c @ (value_type ty) _ _) targets)
  (let
    ( ;; targets
      (taken JumpTarget (jump_target targets 0))
      (not_taken JumpTarget (jump_target targets 1))
      ;; comparison
      (_ Unit (cmp_reg_imm c (imm15 0))))
    (branch_rel (IntCC.NotEqual) taken not_taken)))


;;;; Rules for `jump` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule (lower_branch (jump _) targets)
  (jump_rel (jump_target targets 0)))


;;;; Rules for `br_table` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule (lower_branch (br_table index _) targets)
  (lower_jump_table index targets))


;;;;  Rules for `isplit` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule
  (lower (has_type $I32 (isplit x @ (value_type $I64))))
  (let
    ((t1 Reg (move_reg (value_regs_get x 0)))
      (t2 Reg (move_reg (value_regs_get x 1))))
    (output_pair t1 t2)))

(rule
  (lower (has_type $I64 (isplit x @ (value_type $I128))))
  (let
    ( (t1 Reg (move_reg (value_regs_get x 0)))
      (t2 Reg (move_reg (value_regs_get x 1)))
      (t3 Reg (move_reg (value_regs_get x 2)))
      (t4 Reg (move_reg (value_regs_get x 3))))
    (output_pair (value_regs t1 t2) (value_regs t3 t4))))


;;;;  Rules for `iconcat` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule
  (lower (has_type $I64 (iconcat x @ (value_type $I32) y)))
  (let
    ((t1 Reg (move_reg x))
      (t2 Reg (move_reg y)))
    (value_regs t1 t2)))

(rule
  (lower (has_type $I128 (iconcat x @ (value_type $I64) y)))
  (let
    ( (t1 Reg (move_reg (value_regs_get x 0)))
      (t2 Reg (move_reg (value_regs_get x 1)))
      (t3 Reg (move_reg (value_regs_get y 0)))
      (t4 Reg (move_reg (value_regs_get y 1))))
    (value_regs_four t1 t2 t3 t4)))


;;;;;  Rules for `bmask` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule
  (lower (has_type out_ty (bmask x @ (value_type in_ty))))
  (lower_bmask out_ty in_ty x))


;;;; Rules for `popcnt` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule (lower (has_type $I8 (popcnt x)))
  (let
    ( ;; extend to 32 bit
      (x_ext Reg (ext_to_32 $false x $I8)))
    (libcall_1 (LibCall.PopCnt32) $I32 x_ext $I32)))

(rule (lower (has_type $I16 (popcnt x)))
  (let
    ( ;; extend to 32 bit
      (x_ext Reg (ext_to_32 $false x $I16)))
    (libcall_1 (LibCall.PopCnt32) $I32 x_ext $I32)))

(rule (lower (has_type $I32 (popcnt x)))
  (libcall_1 (LibCall.PopCnt32) $I32 x $I32))

(rule (lower (has_type $I64 (popcnt x)))
  (libcall_1 (LibCall.PopCnt64) $I64 x $I64))

(rule (lower (has_type $I128 (popcnt x)))
  (libcall_1 (LibCall.PopCnt128) $I128 x $I128))


;;;; Rules for `clz` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule (lower (has_type $I8 (clz x)))
  (let
    ( ;; extend to 32 bit
      (x_ext Reg (ext_to_32 $false x $I8))
      ;; perform call
      (count ValueRegs (libcall_1 (LibCall.Clz32) $I32 x_ext $I32)))
    (alu_reg_imm (AluOP.Sub) (value_regs_get count 0) (imm15 24))))

(rule (lower (has_type $I16 (clz x)))
  (let
    ( ;; extend to 32 bit
      (x_ext Reg (ext_to_32 $false x $I16))
      ;; perform call
      (count ValueRegs (libcall_1 (LibCall.Clz32) $I32 x_ext $I32)))
    (alu_reg_imm (AluOP.Sub) (value_regs_get count 0) (imm15 16))))

(rule (lower (has_type $I32 (clz x)))
  (libcall_1 (LibCall.Clz32) $I32 x $I32))

(rule (lower (has_type $I64 (clz x)))
  (libcall_1 (LibCall.Clz64) $I64 x $I64))

(rule (lower (has_type $I128 (clz x)))
  (libcall_1 (LibCall.Clz128) $I128 x $I128))


;;;; Rules for `ctz` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule (lower (has_type $I8 (ctz x)))
  (let
    ( ;; extend to 32 bit
      (x_ext Reg (alu_reg_imm (AluOP.Shl) x (imm15 24)))
      ;; perform call
      (count ValueRegs (libcall_1 (LibCall.Ctz32) $I32 x_ext $I32)))
    (alu_reg_imm (AluOP.Sub) (value_regs_get count 0) (imm15 24))))

(rule (lower (has_type $I16 (ctz x)))
  (let
    ( ;; extend to 32 bit
      (x_ext Reg (alu_reg_imm (AluOP.Shl) x (imm15 16)))
      ;; perform call
      (count ValueRegs (libcall_1 (LibCall.Ctz32) $I32 x_ext $I32)))
    (alu_reg_imm (AluOP.Sub) (value_regs_get count 0) (imm15 16))))

(rule (lower (has_type $I32 (ctz x)))
  (libcall_1 (LibCall.Ctz32) $I32 x $I32))

(rule (lower (has_type $I64 (ctz x)))
  (libcall_1 (LibCall.Ctz64) $I64 x $I64))

(rule (lower (has_type $I128 (ctz x)))
  (libcall_1 (LibCall.Ctz128) $I128 x $I128))


;;;; Rules for `cls` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule (lower (has_type $I8 (cls x)))
  (let
    ( ;; extend to 32 bit
      (x_ext Reg (ext_to_32 $true x $I8))
      ;; perform call
      (count ValueRegs (libcall_1 (LibCall.Cls32) $I32 x_ext $I32)))
    (alu_reg_imm (AluOP.Sub) (value_regs_get count 0) (imm15 24))))

(rule (lower (has_type $I16 (cls x)))
  (let
    ( ;; extend to 32 bit
      (x_ext Reg (ext_to_32 $true x $I16))
      ;; perform call
      (count ValueRegs (libcall_1 (LibCall.Cls32) $I32 x_ext $I32)))
    (alu_reg_imm (AluOP.Sub) (value_regs_get count 0) (imm15 16))))

(rule (lower (has_type $I32 (cls x)))
  (libcall_1 (LibCall.Cls32) $I32 x $I32))

(rule (lower (has_type $I64 (cls x)))
  (libcall_1 (LibCall.Cls64) $I64 x $I64))

(rule (lower (has_type $I128 (cls x)))
  (libcall_1 (LibCall.Cls128) $I128 x $I128))


;;;; Rules for `bitrev` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule (lower (has_type $I32 (bitrev x)))
  (libcall_1 (LibCall.Brev32) $I32 x $I32))

(rule (lower (has_type $I64 (bitrev x)))
  (libcall_1 (LibCall.Brev64) $I64 x $I64))

(rule (lower (has_type $I128 (bitrev x)))
  (libcall_1 (LibCall.Brev128) $I128 x $I128))


;;;;;  Rules for `stack_addr` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule (lower (stack_addr ss offset))
  (gen_stack_addr ss offset))


;;;;;  Rules for `trap` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule (lower (trap code))
  (side_effect (SideEffectNoResult.Inst (MInst.Err code))))


;;;;;  Rules for `select` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule 1
  (lower (has_type (fits_in_32 ty) (select c @ (value_type cty) x y)))
  (let
    ( ;; extend to 32 bit for comparison
      (c_ext Reg (ext_to_32 $false c cty))
      (_ Unit (cmp_reg_imm c_ext (imm15 0))))
    (cond_move_reg_reg (IntCC.Equal) y x)))

(rule 4
  (lower (has_type (fits_in_32 ty) (select c @ (value_type $I64) x y)))
  (let
    ( ;; 64 bit compare
      (_ Unit (cmp_reg_imm (value_regs_get c 0) (imm15 0)))
      (_ Unit (cmpb_reg_imm (value_regs_get c 1) (imm15 0))))
    (cond_move_reg_reg (IntCC.Equal) y x)))

(rule -5
  (lower (has_type $I64 (select c @ (value_type cty) x y)))
  (let
    ( ;; extend to 32 bit for comparison
      (c_ext Reg (ext_to_32 $false c cty))
      (_ Unit (cmp_reg_imm c_ext (imm15 0)))
      (low Reg (cond_move_reg_reg (IntCC.Equal) (value_regs_get y 0) (value_regs_get x 0)))
      (high Reg (cond_move_reg_reg (IntCC.Equal) (value_regs_get y 1) (value_regs_get x 1))))
    (value_regs low high)))

(rule -2
  (lower (has_type $I64 (select c @ (value_type $I64) x y)))
  (let
    ( ;; 64 bit compare
      (_ Unit (cmp_reg_imm (value_regs_get c 0) (imm15 0)))
      (_ Unit (cmpb_reg_imm (value_regs_get c 1) (imm15 0)))
      (low Reg (cond_move_reg_reg (IntCC.Equal) (value_regs_get y 0) (value_regs_get x 0)))
      (high Reg (cond_move_reg_reg (IntCC.Equal) (value_regs_get y 1) (value_regs_get x 1))))
    (value_regs low high)))

(rule 2
  (lower (has_type (fits_in_32 ty) (select (icmp cc a b @ (value_type cty)) x y)))
  (let
    ( ;; extend to 32 bit for comparison
      (a_ext Reg (ext_to_32 (is_signed_cc cc) a cty))
      (b_ext Reg (ext_to_32 (is_signed_cc cc) b cty))
      (_ Unit (cmp_reg_reg a_ext b_ext)))
    (cond_move_reg_reg cc y x)))

(rule 5
  (lower (has_type (fits_in_32 ty) (select (icmp cc a b @ (value_type $I64)) x y)))
  (let
    ( ;; 64 bit compare
      (_ Unit (cmp_reg_reg (value_regs_get a 0) (value_regs_get b 0)))
      (_ Unit (cmpb_reg_reg (value_regs_get a 1) (value_regs_get b 1))))
    (cond_move_reg_reg cc y x)))

(rule -4
  (lower (has_type $I64 (select (icmp cc a b @ (value_type cty)) x y)))
  (let
    ( ;; extend to 32 bit for comparison
      (a_ext Reg (ext_to_32 (is_signed_cc cc) a cty))
      (b_ext Reg (ext_to_32 (is_signed_cc cc) b cty))
      (_ Unit (cmp_reg_reg a_ext b_ext))
      (low Reg (cond_move_reg_reg (IntCC.Equal) (value_regs_get y 0) (value_regs_get x 0)))
      (high Reg (cond_move_reg_reg (IntCC.Equal) (value_regs_get y 1) (value_regs_get x 1))))
    (value_regs low high)))

(rule -1
  (lower (has_type $I64 (select (icmp cc a b @ (value_type $I64)) x y)))
  (let
    ( ;; 64 bit compare
      (_ Unit (cmp_reg_reg (value_regs_get a 0) (value_regs_get b 0)))
      (_ Unit (cmpb_reg_reg (value_regs_get a 1) (value_regs_get b 1)))
      (low Reg (cond_move_reg_reg (IntCC.Equal) (value_regs_get y 0) (value_regs_get x 0)))
      (high Reg (cond_move_reg_reg (IntCC.Equal) (value_regs_get y 1) (value_regs_get x 1))))
    (value_regs low high)))


;;;;;  Rules for `ireduce` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule -1
  (lower (has_type (fits_in_32 ty) (ireduce x @ (value_type $I64))))
  (value_regs_get x 0))

(rule -1
  (lower (has_type (fits_in_32 ty) (ireduce x @ (value_type $I128))))
  (value_regs_get x 0))

(rule -2
  (lower (has_type $I64 (ireduce x @ (value_type $I128))))
  (value_regs (value_regs_get x 0) (value_regs_get x 1)))

(rule -4 (lower (has_type ty (ireduce x))) x)


;;;; Rules for `rotl` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule (lower (has_type $I8 (rotl x y)))
  (lower_i8_rotl x (value_regs_get y 0)))

(rule (lower (has_type $I16 (rotl x y)))
  (lower_i16_rotl x (value_regs_get y 0)))

(rule (lower (has_type $I32 (rotl x y)))
  (lower_i32_rotl x (value_regs_get y 0)))

(rule (lower (has_type $I64 (rotl x y)))
  (lower_i64_rotl x y))

(rule (lower (has_type $I128 (rotl x y)))
  (libcall_2 (LibCall.Rotl128) $I128 x $I8 (value_regs_get y 0) $I128))


;;;; Rules for `rotr` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule (lower (has_type $I8 (rotr x y)))
  (lower_i8_rotr x (value_regs_get y 0)))

(rule (lower (has_type $I16 (rotr x y)))
  (lower_i16_rotr x (value_regs_get y 0)))

(rule (lower (has_type $I32 (rotr x y)))
  (lower_i32_rotr x (value_regs_get y 0)))

(rule (lower (has_type $I64 (rotr x y)))
  (lower_i64_rotr x y))

(rule (lower (has_type $I128 (rotr x y)))
  (libcall_2 (LibCall.Rotr128) $I128 x $I8 (value_regs_get y 0) $I128))


;;;; Rules for `fconst` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule (lower (f32const (u64_from_ieee32 n)))
  (load_imm32 $I32 n))

(rule (lower (f64const (u64_from_ieee64 n)))
  (load_imm64 n))


;;;; Rules for float ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule (lower (has_type $F32 (fadd x y)))
  (libcall_2 (LibCall.AddF32) $F32 x $F32 y $F32))

(rule (lower (has_type $F64 (fadd x y)))
  (libcall_2 (LibCall.AddF64) $F64 x $F64 y $F64))

(rule (lower (has_type $F32 (fsub x y)))
  (libcall_2 (LibCall.SubF32) $F32 x $F32 y $F32))

(rule (lower (has_type $F64 (fsub x y)))
  (libcall_2 (LibCall.SubF64) $F64 x $F64 y $F64))

(rule (lower (has_type $F32 (fmul x y)))
  (libcall_2 (LibCall.MulF32) $F32 x $F32 y $F32))

(rule (lower (has_type $F64 (fmul x y)))
  (libcall_2 (LibCall.MulF64) $F64 x $F64 y $F64))

(rule (lower (has_type $F32 (fdiv x y)))
  (libcall_2 (LibCall.DivF32) $F32 x $F32 y $F32))

(rule (lower (has_type $F64 (fdiv x y)))
  (libcall_2 (LibCall.DivF64) $F64 x $F64 y $F64))

(rule (lower (has_type $F32 (fmin x y)))
  (libcall_2 (LibCall.MinF32) $F32 x $F32 y $F32))

(rule (lower (has_type $F64 (fmin x y)))
  (libcall_2 (LibCall.MinF64) $F64 x $F64 y $F64))

(rule (lower (has_type $F32 (fmax x y)))
  (libcall_2 (LibCall.MaxF32) $F32 x $F32 y $F32))

(rule (lower (has_type $F64 (fmax x y)))
  (libcall_2 (LibCall.MaxF64) $F64 x $F64 y $F64))

(rule (lower (has_type $F32 (fcopysign x y)))
  (libcall_2 (LibCall.CopySignF32) $F32 x $F32 y $F32))

(rule (lower (has_type $F64 (fcopysign x y)))
  (libcall_2 (LibCall.CopySignF64) $F64 x $F64 y $F64))

(rule (lower (has_type $F32 (fneg x)))
  (libcall_1 (LibCall.NegF32) $F32 x $F32))

(rule (lower (has_type $F64 (fneg x)))
  (libcall_1 (LibCall.NegF64) $F64 x $F64))

(rule (lower (has_type $F32 (fabs x)))
  (libcall_1 (LibCall.AbsF32) $F32 x $F32))

(rule (lower (has_type $F64 (fabs x)))
  (libcall_1 (LibCall.AbsF64) $F64 x $F64))

(rule (lower (has_type $F32 (sqrt x)))
  (libcall_1 (LibCall.SqrtF32) $F32 x $F32))

(rule (lower (has_type $F64 (sqrt x)))
  (libcall_1 (LibCall.SqrtF64) $F64 x $F64))

(rule (lower (has_type $F32 (ceil x)))
  (libcall_1 (LibCall.CeilF32) $F32 x $F32))

(rule (lower (has_type $F64 (ceil x)))
  (libcall_1 (LibCall.CeilF64) $F64 x $F64))

(rule (lower (has_type $F32 (floor x)))
  (libcall_1 (LibCall.FloorF32) $F32 x $F32))

(rule (lower (has_type $F64 (floor x)))
  (libcall_1 (LibCall.FloorF64) $F64 x $F64))

(rule (lower (has_type $F32 (trunc x)))
  (libcall_1 (LibCall.TruncF32) $F32 x $F32))

(rule (lower (has_type $F64 (trunc x)))
  (libcall_1 (LibCall.TruncF64) $F64 x $F64))

(rule (lower (has_type $F32 (nearest x)))
  (libcall_1 (LibCall.NearestF32) $F32 x $F32))

(rule (lower (has_type $F64 (nearest x)))
  (libcall_1 (LibCall.NearestF64) $F64 x $F64))

(rule (lower (has_type $F32 (fma x y z)))
  (libcall_3 (LibCall.FmaF32) $F32 x $F32 y $F32 z $F32))

(rule (lower (has_type $F64 (fma x y z)))
  (libcall_3 (LibCall.FmaF64) $F64 x $F64 y $F64 z $F64))

(rule (lower (has_type $F64 (fpromote x)))
  (libcall_1 (LibCall.Promote) $F32 x $F64))

(rule (lower (has_type $F32 (fdemote x)))
  (libcall_1 (LibCall.Demote) $F64 x $F32))


;;;; Rules for float-to-int conversion ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule 1 (lower (has_type $I32 (fcvt_to_uint x @ (value_type $F32))))
  (libcall_1 (LibCall.CvtF32U32) $F32 x $I32))

(rule 1 (lower (has_type $I32 (fcvt_to_sint x @ (value_type $F32))))
  (libcall_1 (LibCall.CvtF32S32) $F32 x $I32))

(rule 1 (lower (has_type $I64 (fcvt_to_uint x @ (value_type $F32))))
  (libcall_1 (LibCall.CvtF32U64) $F32 x $I64))

(rule 1 (lower (has_type $I64 (fcvt_to_sint x @ (value_type $F32))))
  (libcall_1 (LibCall.CvtF32S64) $F32 x $I64))

(rule (lower (has_type $I32 (fcvt_to_uint x @ (value_type $F64))))
  (libcall_1 (LibCall.CvtF64U32) $F64 x $I32))

(rule (lower (has_type $I32 (fcvt_to_sint x @ (value_type $F64))))
  (libcall_1 (LibCall.CvtF64S32) $F64 x $I32))

(rule (lower (has_type $I64 (fcvt_to_uint x @ (value_type $F64))))
  (libcall_1 (LibCall.CvtF64U64) $F64 x $I64))

(rule (lower (has_type $I64 (fcvt_to_sint x @ (value_type $F64))))
  (libcall_1 (LibCall.CvtF64S64) $F64 x $I64))

(rule 1 (lower (has_type $I32 (fcvt_to_uint_sat x @ (value_type $F32))))
  (libcall_1 (LibCall.CvtF32U32Sat) $F32 x $I32))

(rule 1 (lower (has_type $I32 (fcvt_to_sint_sat x @ (value_type $F32))))
  (libcall_1 (LibCall.CvtF32S32Sat) $F32 x $I32))

(rule 1 (lower (has_type $I64 (fcvt_to_uint_sat x @ (value_type $F32))))
  (libcall_1 (LibCall.CvtF32U64Sat) $F32 x $I64))

(rule 1 (lower (has_type $I64 (fcvt_to_sint_sat x @ (value_type $F32))))
  (libcall_1 (LibCall.CvtF32S64Sat) $F32 x $I64))

(rule (lower (has_type $I32 (fcvt_to_uint_sat x @ (value_type $F64))))
  (libcall_1 (LibCall.CvtF64U32Sat) $F64 x $I32))

(rule (lower (has_type $I32 (fcvt_to_sint_sat x @ (value_type $F64))))
  (libcall_1 (LibCall.CvtF64S32Sat) $F64 x $I32))

(rule (lower (has_type $I64 (fcvt_to_uint_sat x @ (value_type $F64))))
  (libcall_1 (LibCall.CvtF64U64Sat) $F64 x $I64))

(rule (lower (has_type $I64 (fcvt_to_sint_sat x @ (value_type $F64))))
  (libcall_1 (LibCall.CvtF64S64Sat) $F64 x $I64))


;;;; Rules for int-to-float conversion ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule 1 (lower (has_type $F32 (fcvt_from_uint x @ (value_type $I32))))
  (libcall_1 (LibCall.CvtU32F32) $I32 x $F32))

(rule 1 (lower (has_type $F32 (fcvt_from_sint x @ (value_type $I32))))
  (libcall_1 (LibCall.CvtS32F32) $I32 x $F32))

(rule 1 (lower (has_type $F32 (fcvt_from_uint x @ (value_type $I64))))
  (libcall_1 (LibCall.CvtU64F32) $I64 x $F32))

(rule 1 (lower (has_type $F32 (fcvt_from_sint x @ (value_type $I64))))
  (libcall_1 (LibCall.CvtS64F32) $I64 x $F32))

(rule (lower (has_type $F64 (fcvt_from_uint x @ (value_type $I32))))
  (libcall_1 (LibCall.CvtU32F64) $I32 x $F64))

(rule (lower (has_type $F64 (fcvt_from_sint x @ (value_type $I32))))
  (libcall_1 (LibCall.CvtS32F64) $I32 x $F64))

(rule (lower (has_type $F64 (fcvt_from_uint x @ (value_type $I64))))
  (libcall_1 (LibCall.CvtU64F64) $I64 x $F64))

(rule (lower (has_type $F64 (fcvt_from_sint x @ (value_type $I64))))
  (libcall_1 (LibCall.CvtS64F64) $I64 x $F64))


;;;; Rules for float comparison ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule 1
  (lower (fcmp cc x @ (value_type $F32) y))
  (let
    ( ;; call comparison function
      (c ValueRegs (libcall_2 (LibCall.CmpF32) $F32 x $F32 y $I8))
      ;; perform bit comparison with mask
      (_ Unit (bit_reg_imm (value_regs_get c 0) (floatcc_mask cc))))
    (cond_move_reg_imm (IntCC.NotEqual) (zero_reg) (imm15 1))))

(rule
  (lower (fcmp cc x @ (value_type $F64) y))
  (let
    ( ;; call comparison function
      (c ValueRegs (libcall_2 (LibCall.CmpF64) $F64 x $F64 y $I8))
      ;; perform bit comparison with mask
      (_ Unit (bit_reg_imm (value_regs_get c 0) (floatcc_mask cc))))
    (cond_move_reg_imm (IntCC.NotEqual) (zero_reg) (imm15 1))))

;; `brif` following `fcmp`
(rule -1
  (lower_branch (brif (fcmp cc x @ (value_type $F64) y) _ _) targets)
  (let
    ( ;; targets
      (taken JumpTarget (jump_target targets 0))
      (not_taken JumpTarget (jump_target targets 1))
      ;; call comparison function
      (c ValueRegs (libcall_2 (LibCall.CmpF64) $F64 x $F64 y $I8))
      ;; perform bit comparison with mask
      (_ Unit (bit_reg_imm (value_regs_get c 0) (floatcc_mask cc))))
    (branch_rel (IntCC.NotEqual) taken not_taken)))

(rule -1
  (lower_branch (brif (fcmp cc x @ (value_type $F32) y) _ _) targets)
  (let
    ( ;; targets
      (taken JumpTarget (jump_target targets 0))
      (not_taken JumpTarget (jump_target targets 1))
      ;; call comparison function
      (c ValueRegs (libcall_2 (LibCall.CmpF32) $F32 x $F32 y $I8))
      ;; perform bit comparison with mask
      (_ Unit (bit_reg_imm (value_regs_get c 0) (floatcc_mask cc))))
    (branch_rel (IntCC.NotEqual) taken not_taken)))


;;;; Rules for float load and store ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule (lower (has_type $F32 (load _ base offset)))
  (load_reg_imm (LoadOP.Ld32) base offset))

(rule
  (lower (has_type $F64 (load _ base offset)))
  (let
    ( ;; low word
      (low Reg (load_reg_imm (LoadOP.Ld32) base offset))
      ;; high word
      (high Reg (load_reg_imm (LoadOP.Ld32) base (add_offset offset 4))))
    (value_regs low high)))

(rule (lower (store _ x @ (value_type $F32) base offset))
  (store_reg_imm (StoreOP.St32) x base offset))

(rule (lower (store _ x @ (value_type $F64) base offset))
  (side_effect (SideEffectNoResult.Inst2
    ;; low word
    (MInst.Store (StoreOP.St32) (value_regs_get x 0) (build_amode base offset))
    ;; high word
    (MInst.Store (StoreOP.St32) (value_regs_get x 1) (build_amode base (add_offset offset 4))))))


;;;; Rules for bitcast ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule (lower (has_type $I32 (bitcast _ x @ (value_type $F32)))) x)

(rule (lower (has_type $F32 (bitcast _ x @ (value_type $I32)))) x)

(rule (lower (has_type $I64 (bitcast _ x @ (value_type $F64)))) x)

(rule (lower (has_type $F64 (bitcast _ x @ (value_type $I64)))) x)
